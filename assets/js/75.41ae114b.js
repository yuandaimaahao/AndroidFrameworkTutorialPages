(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{498:function(r,v,_){"use strict";_.r(v);var e=_(2),t=Object(e.a)({},(function(){var r=this,v=r._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[v("h2",{attrs:{id:"_1-基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本原理"}},[r._v("#")]),r._v(" 1. 基本原理")]),r._v(" "),v("p",[r._v("首先要明确一点 Binder 是一个 RPC（Remote Procedure Call） 框架，也就是说借助于 Binder，我们可以在 A 进程中访问 B 进程中的函数。")]),r._v(" "),v("h3",{attrs:{id:"_1-1-ipc-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-ipc-原理"}},[r._v("#")]),r._v(" 1.1 IPC 原理")]),r._v(" "),v("p",[r._v("RPC 一般基于 IPC（Inter-Process Communication） 来实现的，IPC 就是跨进程数据传输，大白话就是在 A 进程可以访问到 B 进程中的数据，或者说 B 进程中的数据可以传递给 A 进程，都是一个意思。")]),r._v(" "),v("p",[r._v("在 Linux 中，每个进程都有自己的"),v("strong",[r._v("虚拟内存地址空间")]),r._v("。虚拟内存地址空间又分为了用户地址空间和内核地址空间。")]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/20230703172935.png",alt:""}})]),r._v(" "),v("p",[r._v("不同进程之间用户地址空间的变量和函数是不能相互访问的。")]),r._v(" "),v("p",[r._v("使得 A 进程能访问到 B 进程中数据的手段我们就称之为 IPC。")]),r._v(" "),v("p",[r._v("虽然用户地址空间是不能互相访问的，但是不同进程的内核地址空间是映射到相同物理地址的，它们是相同和共享的，我们可以借助内核地址空间作为中转站来实现进程间数据的传输。")]),r._v(" "),v("p",[r._v("具体的我们在 B 进程使用 copy_from_user 将用户态数据 "),v("code",[r._v("int a")]),r._v(" 拷贝到内核态，这样就可以在 A 进程的内核态中访问到 "),v("code",[r._v("int a")])]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/20230703172946.png",alt:""}})]),r._v(" "),v("p",[r._v("更进一步，可以在 A 进程中调用 copy_to_user 可以将 "),v("code",[r._v("int a")]),r._v(" 从内核地址空间拷贝到用户地址空间。至此，我们的进程 A 用户态程序就可以访问到进程 B 中的用户地址空间数据 "),v("code",[r._v("int a")]),r._v(" 了")]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/20230703172958.png",alt:""}})]),r._v(" "),v("p",[r._v("为了访问 "),v("code",[r._v("int a")]),r._v(" ，需要拷贝两次数据。能不能优化一下？我们可以通过 mmap 将进程 A 的用户地址空间与内核地址空间进行映射，让他们指向相同的物理地址空间：")]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/20230703173006.png",alt:""}}),r._v("\n完成映射后，B 进程只需调用一次 copy_from_user，A 进程的用户空间中就可以访问到 "),v("code",[r._v("int a")]),r._v("了。这里就优化到了一次拷贝。")]),r._v(" "),v("h3",{attrs:{id:"_1-2-rpc-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-rpc-原理"}},[r._v("#")]),r._v(" 1.2 RPC 原理")]),r._v(" "),v("p",[r._v("接着我们来看以下，Binder 的 RPC 是如何实现的：")]),r._v(" "),v("p",[r._v("一般来说，A 进程访问 B 进程函数，我们需要：")]),r._v(" "),v("ul",[v("li",[r._v("在 A 进程中按照固定的规则打包数据，这些数据包含了：\n"),v("ul",[v("li",[r._v("数据发给那个进程，Binder 中是一个整型变量 Handle")]),r._v(" "),v("li",[r._v("要调用目标进程中的那个函数，Binder 中用一个整型变量 Code 表示")]),r._v(" "),v("li",[r._v("目标函数的参数")]),r._v(" "),v("li",[r._v("要执行具体什么操作，也就是 Binder 协议")])])]),r._v(" "),v("li",[r._v("进程 B 收到数据，按照固定的格式解析出数据，调用函数，并使用相同的格式将函数的返回值传递给进程 A。")])]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/20230703173016.png",alt:""}})]),r._v(" "),v("p",[r._v("Binder 要实现的效果就是，整体上看过去，进程 A 执行进程 B 中的函数就和执行当前进程中的函数是一样的。")]),r._v(" "),v("h2",{attrs:{id:"_2-binder-应用层工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-binder-应用层工作流程"}},[r._v("#")]),r._v(" 2. Binder 应用层工作流程")]),r._v(" "),v("p",[r._v("Binder 是一个 "),v("strong",[r._v("RPC")]),r._v("（Remote Procedure Call） 框架，翻译成中文就是"),v("strong",[r._v("远程过程调用")]),r._v("。也就是说通过 Binder：")]),r._v(" "),v("ul",[v("li",[r._v("可以在 A 进程中访问 B 进程中定义的函数")]),r._v(" "),v("li",[r._v("进程 B 中的这些等待着被远程调用的函数的集合，我们称其为 "),v("strong",[r._v("Binder 服务（Binder Service）")])]),r._v(" "),v("li",[r._v("进程 A 称之为 "),v("strong",[r._v("Binder 客户端（Binder Client）")]),r._v("，进程 B 称之为 "),v("strong",[r._v("Binder 服务端（Binder Server）")])]),r._v(" "),v("li",[r._v("通常，系统中的服务很多，我们需要一个管家来管理它们，"),v("strong",[r._v("服务管家（ServiceManager）")]),r._v(" 是 Android 系统启动时，启动的一个用于管理 "),v("strong",[r._v("Binder 服务（Binder Service）")]),r._v(" 的进程。通常，"),v("strong",[r._v("服务（Service）")]),r._v(" 需要事先注册到"),v("strong",[r._v("服务管家（ServiceManager）")]),r._v("，其他进程向"),v("strong",[r._v("服务管家（ServiceManager）")]),r._v(" 查询服务后才能使用服务。")]),r._v(" "),v("li",[r._v("Binder 的 RPC 能力通过 "),v("strong",[r._v("Binder 驱动")]),r._v("实现")])]),r._v(" "),v("p",[r._v("通常一个完整的 Binder 程序涉及 4 个流程：")]),r._v(" "),v("ol",[v("li",[r._v("在 Binder Server 端定义好服务")]),r._v(" "),v("li",[r._v("然后向 ServiceManager 注册服务")]),r._v(" "),v("li",[r._v("在 Binder Client 中向 ServiceManager 获取到服务")]),r._v(" "),v("li",[r._v("发起远程调用，调用 Binder Server 中定义好的服务")])]),r._v(" "),v("p",[r._v("整个流程都是建立在 Binder 驱动提供的跨进程调用能力之上：")]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/20230703173026.png",alt:""}})]),r._v(" "),v("h2",{attrs:{id:"关于"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于"}},[r._v("#")]),r._v(" 关于")]),r._v(" "),v("p",[r._v("我叫阿豪，2015 年本科毕业于国防科学技术大学指挥信息系统专业，毕业后从事信息化装备的研发工作，主要研究方向是 Android Framework 与 Linux Kernel。")]),r._v(" "),v("p",[r._v("如果你对 Android Framework 感兴趣或者正在学习 Android Framework，可以关注我的微信公众号和抖音，我会持续分享我的学习经验，帮助正在学习的你少走一些弯路。学习过程中如果你有疑问或者你的经验想要分享给大家可以添加我的微信，我拉你进技术交流群。")]),r._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/zzh0838/MyImages@main/img/%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg",alt:""}})])])}),[],!1,null,null,null);v.default=t.exports}}]);